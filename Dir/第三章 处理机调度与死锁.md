#第三章 处理机调度与死锁

本章内容：处理机调度的层次、调度准则、调度算法、产生死锁的原因和必要条件、预防死锁的方法、死锁的检测与解除
主要考点：处理机调度的三个层次、调度准则、调度算法、实时调度算法、产生死锁的原因和必要条件、★★利用银行家算法避免死锁、死锁的检测与解除


###1、一个作业从提交开始，往往要经历三级调度：高级调度、低级调度、中级调度。
高级调度：又称为作业调度或长程调度，其主要功能是根据某种算法，把外存上处于后备队列中的那些作业调入内存。它调度的对象是作业。
低级调度：又称进程调度或短程调度。主要功能：保存处理机的现场信息、按某种算法选取进程、把处理器分配给进程。常采用非抢占（非剥夺）方式和抢占（剥夺）方式两种。它所调度的对象是进程（或内核级线程）。
中级调度：又称中程调度。在内存和外存对换区之间按照给定的原则和策略选择进程对换，以解决内存紧张问题，从而提高内存的利用率和系统吞吐量。
###2、选择调度方式和调度算法的准则
  面向用户的准则：（1）周转时间短(2) 响应时间快(3) 截止时间的保证(4) 优先权准则
  面向系统的准则：(1) 系统吞吐量高(2) 处理机利用率好(3) 各类资源的平衡利用
###3、常见的调度算法有：先来先服务调度算法（FCFS）、短作业/进程优先调度算法（SJF/SPF）、高优先权优先调度算法、基于时间片的轮转调度算法。
###4、进程调度算法采用时间片轮转法时，时间片过大会使轮转法转为先来先服务调度算法（FCFS）。
###5、若使当前运行的进程总是优先级最高的进程，则应该选择进程高优先权优先调度算法
###6、在响应比最高者优先的作业调度算法中，当各个作业等待时间相同时，运行时间短的作业将得到优先调度；当各个作业要求运行的时间相同时，等待时间长的作业得到优先调度。
###7、一个理想的作业调度算法应该是既能提高系统的效率，又能使系统的作业及时得到结果。
###8、常用的几种实时调度算法有：最早截止时间优先算法（EDF）、最低松弛度优先算法（LLF）
最早截止时间优先算法：该算法是根据任务的开始截止时间来确定任务的优先级。开始截止时间越早，其优先级越高
最低松弛度优先算法：该算法是根据任务紧急（或松弛）的程序，来确定任务的优先级。任务的紧急度越高，其优先级越高，并使之优先执行
###9、死锁的定义
指多个进程在运行过程中因争夺资源而造成的一种僵局（deadly-Embrace)，若无外力作用，这些进程都将无法向前推进。
###10、产生死锁的原因有两个：竞争资源、进程间推进顺序非法。
###★11、产生死锁的四个必要条件是
>互斥条件、请求和保持条件、不剥夺条件、循环等待条件。
##12、处理死锁的基本方法是：
>预防死锁、避免死锁、检测死锁、解除死锁。
###13、什么是系统的安全状态，避免死锁的实质是什么？
系统的安全状态是指在某一时刻，系统能按某种进程顺序(p1, p2,…，pn)来为每个进程Pi分配其资源,直到满足每个进程对资源的最大需求,使每个进程都可顺利地完成，则称此时的系统状态为安全状态.称序列<p1, p2,…，pn>为安全序列。如果一个系统在安全状态，就没有死锁。如果一个系统处于不安全状态，就有可能死锁。避免死锁的实质：确保系统不进入不安全状态。	

###★★14、利用银行家算法避免死锁
●储备知识
银行家算法中的数据结构：假定系统中有n个进程（P1，P2，…，Pn），m类资源（R1，R2，…，Rm），银行家算法中使用的数据结构如下：
▲可利用资源向量: Available[j]=K, 表示系统资源Rj类资源有K个可用
▲最大需求矩阵: Max[i,j]=K, 表示进程Pi需要Rj类资源的最大数目是K个
▲分配矩阵：Allocation[i,j]=K, 表示进程Pi当前已经分配到K个Rj类资源
▲需求矩阵：Need[i,j]=K, 表示进程Pi还需要K个Rj类资源方能完成任务
三个矩阵的关系：
```
Need [i,j] = Max[i,j] – Allocation [i,j].
银行家算法：设Requesti是进程Pi的请求向量，设Requesti [j] =K，表示进程Pi请求分配Rj类资源K个。当进程Pi发出资源请求后，系统按如下步骤进行检查：
(1)如Requesti[j]≤Need[i,j], 转(2);否则出错，因为进程申请资源量超过它申明的最大量。
(2)如Requesti[j] ≤Available[j],转(3); 否则表资源不够,需等待。
(3)系统试分配资源给进程Pi,并作如下修改：
Available[j]= Available[j]- Requesti[j]
Allocation[i,j]= Allocation[i,j]+ Requesti[j]
Need[i,j]= Need[i,j]- Requesti[j]
(4)系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全,则正式进行分配,否则恢复原状态让进程Pi等待。
安全性算法：为了进行安全性检查，需要定义如下数据结构：
（1）工作向量Work，它表示系统可以提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时， Work= Available
（2）Finish ，它表示系统是否有足够的资源分配给进程，使之运行完成。开始时, Finish[i]=false;当有足够资源分配给进程Pi时，令Finish[i]=true。
```
安全性检查算法执行步骤：
```
(1) Work := Available
             Finish [i] = false
(2)寻找满足如下条件的进程Pi
 Finish [i] = false
 Need[i,j] ≤Work[j]，如果找到，转(3)，否则转(4)
(3)当进程Pi获得资源后，可顺利执行完，并释放分配给它的资源，故执行：
             Work [j]= Work [j]+ Allocation[i,j]；
             Finish[i] = ture；
转 (2).
(4)若所有进程的Finish [i] = true ，则表示系统处于安全状态，否则处于不安全状态

```
●银行家算法例题：在银行家算法中，若出现下述资源分配情：
Process	Allocation	Need	Available
P0	0032	0012	1622
P1	1000	1750	
P2	1354	2356	
P3	0332	0652	
P4	0014	0656	
试问：
⑴ 该状态是否安全？
⑵ 若进程P2提出请求Request(1，2，2，2)后，系统能否将资源分配给它？
解：⑴该状态是安全的，因为存在一个安全序列< P0P3P4P1P2>。下表为该时刻的安全序列表。
资源情况
进程	Work	Need	Allocation	Work+Allocation	Finish
P0
P3
P4
P1
P2	1 6 2 2
1 6 5 4
1 9 8 6
1 9 9 10
2 9 9 10	0 0 1 2
0 6 5 2
0 6 5 6
1 7 5 0
2 3 5 6	0 0 3 2
0 3 3 2
0 0 1 4
1 0 0 0
1 3 5 4	1 6 5 4
1 9 8 6
1 9 9 10
2 9 9 10
3 12 14 14	true
true
true
true
true
   ⑵若进程P2提出请求Request(1，2，2，2)后，系统不能将资源分配给它，若分配给进程P2，系统还剩的资源情况为（0，4，0，0），此时系统中的资源将无法满足任何一个进程的资源请求，从而导致系统进入不安全状态，容易引起死锁的发生。
（书上例题雷同，在P110，可同步参考）
15、确定系统处于S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。 
16、常用的解除死锁方法有两种:资源剥夺法、撤消进程法。
资源剥夺法：当发现死锁后,从其进程剥夺足够数量的资源给死锁进程,以解除死锁状态。
撤消进程法：采用强制手段从系统中撤消一个/一部分死锁进程,并剥夺这些进程的资源供其它死锁进程使用。


---


###1.高级调度又称为作业调度或长程调度，
>其主要功能是根据某种算法，把外存上处于后备队列的那些作业调入内存，也就是说，它的调度对象是作业。

###2.作业控制块是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。

###3.作业调度的主要功能是根据作业控制块中的信息
>审查系统能否满足用户作业的咨询需求，以及按照一定的算法，
从外存的后备队列中选取某些作业调入内存，并为它们创建进程，分配必要的资源。然后再将新创建的进程插入就绪队列，准备执行。

###4.低级调度所调度的对象是进程。主要功能：
	>(1)保存处理机的现场信息。
	>(2)按某种算法选取进程。
	>(3)把处理器分配给进程。
###5.进程调度中的三个基本机制：
>(1)排队器(2)分派器(3)上下文切换机制。
###6.进程调度方式：
>(1)非抢占方式(2)抢占方式。
###7.中级调度的主要目的是为了提高内存利用率和系统吞吐量。
###8.调度算法是指根据系统的资源分配策略所规定的资源分配方法。

